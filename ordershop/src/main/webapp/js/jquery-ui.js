/*! jQuery UI - v1.14.1 - 2024-10-30
* https://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-patch.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
* Copyright OpenJS Foundation and other contributors; Licensed MIT */

( function( factory ) {
   "use strict";

   if ( typeof define === "function" && define.amd ) {

      // AMD. Register as an anonymous module.
      define( [ "jquery" ], factory );
   } else {

      // Browser globals
      factory( jQuery );
   }
} )( function( $ ) {
"use strict";

$.ui = $.ui || {};

var version = $.ui.version = "1.14.1";


/*!
 * jQuery UI Widget 1.14.1
 * https://jqueryui.com
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license.
 * https://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: https://api.jqueryui.com/jQuery.widget/
//>>demos: https://jqueryui.com/widget/


var widgetUuid = 0;
var widgetHasOwnProperty = Array.prototype.hasOwnProperty;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
   return function( elems ) {
      var events, elem, i;
      for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {

         // Only trigger remove when necessary to save time
         events = $._data( elem, "events" );
         if ( events && events.remove ) {
            $( elem ).triggerHandler( "remove" );
         }
      }
      orig( elems );
   };
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
   var existingConstructor, constructor, basePrototype;

   // ProxiedPrototype allows the provided prototype to remain unmodified
   // so that it can be used as a mixin for multiple widgets (#8876)
   var proxiedPrototype = {};

   var namespace = name.split( "." )[ 0 ];
   name = name.split( "." )[ 1 ];
   if ( name === "__proto__" || name === "constructor" ) {
      return $.error( "Invalid widget name: " + name );
   }
   var fullName = namespace + "-" + name;

   if ( !prototype ) {
      prototype = base;
      base = $.Widget;
   }

   if ( Array.isArray( prototype ) ) {
      prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
   }

   // Create selector for plugin
   $.expr.pseudos[ fullName.toLowerCase() ] = function( elem ) {
      return !!$.data( elem, fullName );
   };

   $[ namespace ] = $[ namespace ] || {};
   existingConstructor = $[ namespace ][ name ];
   constructor = $[ namespace ][ name ] = function( options, element ) {

      // Allow instantiation without "new" keyword
      if ( !this || !this._createWidget ) {
         return new constructor( options, element );
      }

      // Allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      if ( arguments.length ) {
         this._createWidget( options, element );
      }
   };

   // Extend with the existing constructor to carry over any static properties
   $.extend( constructor, existingConstructor, {
      version: prototype.version,

      // Copy the object used to create the prototype in case we need to
      // redefine the widget later
      _proto: $.extend( {}, prototype ),

      // Track widgets that inherit from this widget in case this widget is
      // redefined after a widget inherits from it
      _childConstructors: []
   } );

   basePrototype = new base();

   // We need to make the options hash a property directly on the new instance
   // otherwise we'll modify the options hash on the prototype that we're
   // inheriting from
   basePrototype.options = $.widget.extend( {}, basePrototype.options );
   $.each( prototype, function( prop, value ) {
      if ( typeof value !== "function" ) {
         proxiedPrototype[ prop ] = value;
         return;
      }
      proxiedPrototype[ prop ] = ( function() {
         function _super() {
            return base.prototype[ prop ].apply( this, arguments );
         }

         function _superApply( args ) {
            return base.prototype[ prop ].apply( this, args );
         }

         return function() {
            var __super = this._super;
            var __superApply = this._superApply;
            var returnValue;

            this._super = _super;
            this._superApply = _superApply;

            returnValue = value.apply( this, arguments );

            this._super = __super;
            this._superApply = __superApply;

            return returnValue;
         };
      } )();
   } );
   constructor.prototype = $.widget.extend( basePrototype, {

      // TODO: remove support for widgetEventPrefix
      // always use the name + a colon as the prefix, e.g., draggable:start
      // don't prefix for widgets that aren't DOM-based
      widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
   }, proxiedPrototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      widgetFullName: fullName
   } );

   // If this widget is being redefined then we need to find all widgets that
   // are inheriting from it and redefine all of them so that they inherit from
   // the new version of this widget. We're essentially trying to replace one
   // level in the prototype chain.
   if ( existingConstructor ) {
      $.each( existingConstructor._childConstructors, function( i, child ) {
         var childPrototype = child.prototype;

         // Redefine the child widget using the same prototype that was
         // originally used, but inherit from the new version of the base
         $.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
            child._proto );
      } );

      // Remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
   } else {
      base._childConstructors.push( constructor );
   }

   $.widget.bridge( name, constructor );

   return constructor;
};

$.widget.extend = function( target ) {
   var input = widgetSlice.call( arguments, 1 );
   var inputIndex = 0;
   var inputLength = input.length;
   var key;
   var value;

   for ( ; inputIndex < inputLength; inputIndex++ ) {
      for ( key in input[ inputIndex ] ) {
         value = input[ inputIndex ][ key ];
         if ( widgetHasOwnProperty.call( input[ inputIndex ], key ) && value !== undefined ) {

            // Clone objects
            if ( $.isPlainObject( value ) ) {
               target[ key ] = $.isPlainObject( target[ key ] ) ?
                  $.widget.extend( {}, target[ key ], value ) :

                  // Don't extend strings, arrays, etc. with objects
                  $.widget.extend( {}, value );

            // Copy everything else by reference
            } else {
               target[ key ] = value;
            }
         }
      }
   }
   return target;
};

$.widget.bridge = function( name, object ) {
   var fullName = object.prototype.widgetFullName || name;
   $.fn[ name ] = function( options ) {
      var isMethodCall = typeof options === "string";
      var args = widgetSlice.call( arguments, 1 );
      var returnValue = this;

      if ( isMethodCall ) {

         // If this is an empty collection, we need to have the instance method
         // return undefined instead of the jQuery instance
         if ( !this.length && options === "instance" ) {
            returnValue = undefined;
         } else {
            this.each( function() {
               var methodValue;
               var instance = $.data( this, fullName );

               if ( options === "instance" ) {
                  returnValue = instance;
                  return false;
               }

               if ( !instance ) {
                  return $.error( "cannot call methods on " + name +
                     " prior to initialization; " +
                     "attempted to call method '" + options + "'" );
               }

               if ( typeof instance[ options ] !== "function" ||
                  options.charAt( 0 ) === "_" ) {
                  return $.error( "no such method '" + options + "' for " + name +
                     " widget instance" );
               }

               methodValue = instance[ options ].apply( instance, args );

               if ( methodValue !== instance && methodValue !== undefined ) {
                  returnValue = methodValue && methodValue.jquery ?
                     returnValue.pushStack( methodValue.get() ) :
                     methodValue;
                  return false;
               }
            } );
         }
      } else {

         // Allow multiple hashes to be passed on init
         if ( args.length ) {
            options = $.widget.extend.apply( null, [ options ].concat( args ) );
         }

         this.each( function() {
            var instance = $.data( this, fullName );
            if ( instance ) {
               instance.option( options || {} );
               if ( instance._init ) {
                  instance._init();
               }
            } else {
               $.data( this, fullName, new object( options, this ) );
            }
         } );
      }

      return returnValue;
   };
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
   widgetName: "widget",
   widgetEventPrefix: "",
   defaultElement: "<div>",

   options: {
      classes: {},
      disabled: false,

      // Callbacks
      create: null
   },

   _createWidget: function( options, element ) {
      element = $( element || this.defaultElement || this )[ 0 ];
      this.element = $( element );
      this.uuid = widgetUuid++;
      this.eventNamespace = "." + this.widgetName + this.uuid;

      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();
      this.classesElementLookup = {};

      if ( element !== this ) {
         $.data( element, this.widgetFullName, this );
         this._on( true, this.element, {
            remove: function( event ) {
               if ( event.target === element ) {
                  this.destroy();
               }
            }
         } );
         this.document = $( element.style ?

            // Element within the document
            element.ownerDocument :

            // Element is window or document
            element.document || element );
         this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
      }

      this.options = $.widget.extend( {},
         this.options,
         this._getCreateOptions(),
         options );

      this._create();

      if ( this.options.disabled ) {
         this._setOptionDisabled( this.options.disabled );
      }

      this._trigger( "create", null, this._getCreateEventData() );
      this._init();
   },

   _getCreateOptions: function() {
      return {};
   },

   _getCreateEventData: $.noop,

   _create: $.noop,

   _init: $.noop,

   destroy: function() {
      var that = this;

      this._destroy();
      $.each( this.classesElementLookup, function( key, value ) {
         that._removeClass( value, key );
      } );

      // We can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element
         .off( this.eventNamespace )
         .removeData( this.widgetFullName );
      this.widget()
         .off( this.eventNamespace )
         .removeAttr( "aria-disabled" );

      // Clean up events and states
      this.bindings.off( this.eventNamespace );
   },

   _destroy: $.noop,

   widget: function() {
      return this.element;
   },

   option: function( key, value ) {
      var options = key;
      var parts;
      var curOption;
      var i;

      if ( arguments.length === 0 ) {

         // Don't return a reference to the internal hash
         return $.widget.extend( {}, this.options );
      }

      if ( typeof key === "string" ) {

         // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
         options = {};
         parts = key.split( "." );
         key = parts.shift();
         if ( parts.length ) {
            curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
            for ( i = 0; i < parts.length - 1; i++ ) {
               curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
               curOption = curOption[ parts[ i ] ];
            }
            key = parts.pop();
            if ( arguments.length === 1 ) {
               return curOption[ key ] === undefined ? null : curOption[ key ];
            }
            curOption[ key ] = value;
         } else {
            if ( arguments.length === 1 ) {
               return this.options[ key ] === undefined ? null : this.options[ key ];
            }
            options[ key ] = value;
         }
      }

      this._setOptions( options );

      return this;
   },

   _setOptions: function( options ) {
      var key;

      for ( key in options ) {
         this._setOption( key, options[ key ] );
      }

      return this;
   },

   _setOption: function( key, value ) {
      if ( key === "classes" ) {
         this._setOptionClasses( value );
      }

      this.options[ key ] = value;

      if ( key === "disabled" ) {
         this._setOptionDisabled( value );
      }

      return this;
   },

   _setOptionClasses: function( value ) {
      var classKey, elements, currentElements;

      for ( classKey in value ) {
         currentElements = this.classesElementLookup[ classKey ];
         if ( value[ classKey ] === this.options.classes[ classKey ] ||
               !currentElements ||
               !currentElements.length ) {
            continue;
         }

         // We are doing this to create a new jQuery object because the _removeClass() call
         // on the next line is going to destroy the reference to the current elements being
         // tracked. We need to save a copy of this collection so that we can add the new classes
         // below.
         elements = $( currentElements.get() );
         this._removeClass( currentElements, classKey );

         // We don't use _addClass() here, because that uses this.options.classes
         // for generating the string of classes. We want to use the value passed in from
         // _setOption(), this is the new value of the classes option which was passed to
         // _setOption(). We pass this value directly to _classes().
         elements.addClass( this._classes( {
            element: elements,
            keys: classKey,
            classes: value,
            add: true
         } ) );
      }
   },

   _setOptionDisabled: function( value ) {
      this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

      // If the widget is becoming disabled, then nothing is interactive
      if ( value ) {
         this._removeClass( this.hoverable, null, "ui-state-hover" );
         this._removeClass( this.focusable, null, "ui-state-focus" );
      }
   },

   enable: function() {
      return this._setOptions( { disabled: false } );
   },

   disable: function() {
      return this._setOptions( { disabled: true } );
   },

   _classes: function( options ) {
      var full = [];
      var that = this;

      options = $.extend( {
         element: this.element,
         classes: this.options.classes || {}
      }, options );

      function bindRemoveEvent() {
         var nodesToBind = [];

         options.element.each( function( _, element ) {
            var isTracked = $.map( that.classesElementLookup, function( elements ) {
               return elements;
            } )
               .some( function( elements ) {
                  return elements.is( element );
               } );

            if ( !isTracked ) {
               nodesToBind.push( element );
            }
         } );

         that._on( $( nodesToBind ), {
            remove: "_untrackClassesElement"
         } );
      }

      function processClassString( classes, checkOption ) {
         var current, i;
         for ( i = 0; i < classes.length; i++ ) {
            current = that.classesElementLookup[ classes[ i ] ] || $();
            if ( options.add ) {
               bindRemoveEvent();
               current = $( $.uniqueSort( current.get().concat( options.element.get() ) ) );
            } else {
               current = $( current.not( options.element ).get() );
            }
            that.classesElementLookup[ classes[ i ] ] = current;
            full.push( classes[ i ] );
            if ( checkOption && options.classes[ classes[ i ] ] ) {
               full.push( options.classes[ classes[ i ] ] );
            }
         }
      }

      if ( options.keys ) {
         processClassString( options.keys.match( /\S+/g ) || [], true );
      }
      if ( options.extra ) {
         processClassString( options.extra.match( /\S+/g ) || [] );
      }

      return full.join( " " );
   },

   _untrackClassesElement: function( event ) {
      var that = this;
      $.each( that.classesElementLookup, function( key, value ) {
         if ( $.inArray( event.target, value ) !== -1 ) {
            that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
         }
      } );

      this._off( $( event.target ) );
   },

   _removeClass: function( element, keys, extra ) {
      return this._toggleClass( element, keys, extra, false );
   },

   _addClass: function( element, keys, extra ) {
      return this._toggleClass( element, keys, extra, true );
   },

   _toggleClass: function( element, keys, extra, add ) {
      add = ( typeof add === "boolean" ) ? add : extra;
      var shift = ( typeof element === "string" || element === null ),
         options = {
            extra: shift ? keys : extra,
            keys: shift ? element : keys,
            element: shift ? this.element : element,
            add: add
         };
      options.element.toggleClass( this._classes( options ), add );
      return this;
   },

   _on: function( suppressDisabledCheck, element, handlers ) {
      var delegateElement;
      var instance = this;

      // No suppressDisabledCheck flag, shuffle arguments
      if ( typeof suppressDisabledCheck !== "boolean" ) {
         handlers = element;
         element = suppressDisabledCheck;
         suppressDisabledCheck = false;
      }

      // No element argument, shuffle and use this.element
      if ( !handlers ) {
         handlers = element;
         element = this.element;
         delegateElement = this.widget();
      } else {
         element = delegateElement = $( element );
         this.bindings = this.bindings.add( element );
      }

      $.each( handlers, function( event, handler ) {
         function handlerProxy() {

            // Allow widgets to customize the disabled handling
            // - disabled as an array instead of boolean
            // - disabled class as method for disabling individual parts
            if ( !suppressDisabledCheck &&
                  ( instance.options.disabled === true ||
                  $( this ).hasClass( "ui-state-disabled" ) ) ) {
               return;
            }
            return ( typeof handler === "string" ? instance[ handler ] : handler )
               .apply( instance, arguments );
         }

         // Copy the guid so direct unbinding works
         if ( typeof handler !== "string" ) {
            handlerProxy.guid = handler.guid =
               handler.guid || handlerProxy.guid || $.guid++;
         }

         var match = event.match( /^([\w:-]*)\s*(.*)$/ );
         var eventName = match[ 1 ] + instance.eventNamespace;
         var selector = match[ 2 ];

         if ( selector ) {
            delegateElement.on( eventName, selector, handlerProxy );
         } else {
            element.on( eventName, handlerProxy );
         }
      } );
   },

   _off: function( element, eventName ) {
      eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
         this.eventNamespace;
      element.off( eventName );

      // Clear the stack to avoid memory leaks (#10056)
      this.bindings = $( this.bindings.not( element ).get() );
      this.focusable = $( this.focusable.not( element ).get() );
      this.hoverable = $( this.hoverable.not( element ).get() );
   },

   _delay: function( handler, delay ) {
      function handlerProxy() {
         return ( typeof handler === "string" ? instance[ handler ] : handler )
            .apply( instance, arguments );
      }
      var instance = this;
      return setTimeout( handlerProxy, delay || 0 );
   },

   _hoverable: function( element ) {
      this.hoverable = this.hoverable.add( element );
      this._on( element, {
         mouseenter: function( event ) {
            this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
         },
         mouseleave: function( event ) {
            this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
         }
      } );
   },

   _focusable: function( element ) {
      this.focusable = this.focusable.add( element );
      this._on( element, {
         focusin: function( event ) {
            this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
         },
         focusout: function( event ) {
            this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
         }
      } );
   },

   _trigger: function( type, event, data ) {
      var prop, orig;
      var callback = this.options[ type ];

      data = data || {};
      event = $.Event( event );
      event.type = ( type === this.widgetEventPrefix ?
         type :
         this.widgetEventPrefix + type ).toLowerCase();

      // The original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[ 0 ];

      // Copy original event properties over to the new event
      orig = event.originalEvent;
      if ( orig ) {
         for ( prop in orig ) {
            if ( !( prop in event ) ) {
               event[ prop ] = orig[ prop ];
            }
         }
      }

      this.element.trigger( event, data );
      return !( typeof callback === "function" &&
         callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
         event.isDefaultPrevented() );
   }
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
   $.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
      if ( typeof options === "string" ) {
         options = { effect: options };
      }

      var hasOptions;
      var effectName = !options ?
         method :
         options === true || typeof options === "number" ?
            defaultEffect :
            options.effect || defaultEffect;

      options = options || {};
      if ( typeof options === "number" ) {
         options = { duration: options };
      } else if ( options === true ) {
         options = {};
      }

      hasOptions = !$.isEmptyObject( options );
      options.complete = callback;

      if ( options.delay ) {
         element.delay( options.delay );
      }

      if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
         element[ method ]( options );
      } else if ( effectName !== method && element[ effectName ] ) {
         element[ effectName ]( options.duration, options.easing, callback );
      } else {
         element.queue( function( next ) {
            $( this )[ method ]();
            if ( callback ) {
               callback.call( element[ 0 ] );
            }
            next();
         } );
      }
   };
} );

var widget = $.widget;


/*!
 * jQuery UI Position 1.14.1
 * https://jqueryui.com
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license.
 * https://jquery.org/license
 *
 * https://api.jqueryui.com/position/
 */

//>>label: Position
//>>group: Core
//>>description: Positions elements relative to other elements.
//>>docs: https://api.jqueryui.com/position/
//>>demos: https://jqueryui.com/position/


( function() {
var cachedScrollbarWidth,
   max = Math.max,
   abs = Math.abs,
   rhorizontal = /left|center|right/,
   rvertical = /top|center|bottom/,
   roffset = /[\+\-]\d+(\.[\d]+)?%?/,
   rposition = /^\w+/,
   rpercent = /%$/,
   _position = $.fn.position;

function getOffsets( offsets, width, height ) {
   return [
      parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
      parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
   ];
}

function parseCss( element, property ) {
   return parseInt( $.css( element, property ), 10 ) || 0;
}

function isWindow( obj ) {
   return obj != null && obj === obj.window;
}

function getDimensions( elem ) {
   var raw = elem[ 0 ];
   if ( raw.nodeType === 9 ) {
      return {
         width: elem.width(),
         height: elem.height(),
         offset: { top: 0, left: 0 }
      };
   }
   if ( isWindow( raw ) ) {
      return {
         width: elem.width(),
         height: elem.height(),
         offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
      };
   }
   if ( raw.preventDefault ) {
      return {
         width: 0,
         height: 0,
         offset: { top: raw.pageY, left: raw.pageX }
      };
   }
   return {
      width: elem.outerWidth(),
      height: elem.outerHeight(),
      offset: elem.offset()
   };
}

$.position = {
   scrollbarWidth: function() {
      if ( cachedScrollbarWidth !== undefined ) {
         return cachedScrollbarWidth;
      }
      var w1, w2,
         div = $( "<div style=" +
            "'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>" +
            "<div style='height:300px;width:auto;'></div></div>" ),
         innerDiv = div.children()[ 0 ];

      $( "body" ).append( div );
      w1 = innerDiv.offsetWidth;
      div.css( "overflow", "scroll" );

      w2 = innerDiv.offsetWidth;

      if ( w1 === w2 ) {
         w2 = div[ 0 ].clientWidth;
      }

      div.remove();

      return ( cachedScrollbarWidth = w1 - w2 );
   },
   getScrollInfo: function( within ) {
      var overflowX = within.isWindow || within.isDocument ? "" :
            within.element.css( "overflow-x" ),
         overflowY = within.isWindow || within.isDocument ? "" :
            within.element.css( "overflow-y" ),
         hasOverflowX = overflowX === "scroll" ||
            ( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
         hasOverflowY = overflowY === "scroll" ||
            ( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
      return {
         width: hasOverflowY ? $.position.scrollbarWidth() : 0,
         height: hasOverflowX ? $.position.scrollbarWidth() : 0
      };
   },
   getWithinInfo: function( element ) {
      var withinElement = $( element || window ),
         isElemWindow = isWindow( withinElement[ 0 ] ),
         isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
         hasOffset = !isElemWindow && !isDocument;
      return {
         element: withinElement,
         isWindow: isElemWindow,
         isDocument: isDocument,
         offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
         scrollLeft: withinElement.scrollLeft(),
         scrollTop: withinElement.scrollTop(),
         width: withinElement.outerWidth(),
         height: withinElement.outerHeight()
      };
   }
};

$.fn.position = function( options ) {
   if ( !options || !options.of ) {
      return _position.apply( this, arguments );
   }

   // Make a copy, we don't want to modify arguments
   options = $.extend( {}, options );

   var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,

      // Make sure string options are treated as CSS selectors
      target = typeof options.of === "string" ?
         $( document ).find( options.of ) :
         $( options.of ),

      within = $.position.getWithinInfo( options.within ),
      scrollInfo = $.position.getScrollInfo( within ),
      collision = ( options.collision || "flip" ).split( " " ),
      offsets = {};

   dimensions = getDimensions( target );
   if ( target[ 0 ].preventDefault ) {

      // Force left top to allow flipping
      options.at = "left top";
   }
   targetWidth = dimensions.width;
   targetHeight = dimensions.height;
   targetOffset = dimensions.offset;

   // Clone to reuse original targetOffset later
   basePosition = $.extend( {}, targetOffset );

   // Force my and at to have valid horizontal and vertical positions
   // if a value is missing or invalid, it will be converted to center
   $.each( [ "my", "at" ], function() {
      var pos = ( options[ this ] || "" ).split( " " ),
         horizontalOffset,
         verticalOffset;

      if ( pos.length === 1 ) {
         pos = rhorizontal.test( pos[ 0 ] ) ?
            pos.concat( [ "center" ] ) :
            rvertical.test( pos[ 0 ] ) ?
               [ "center" ].concat( pos ) :
               [ "center", "center" ];
      }
      pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
      pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

      // Calculate offsets
      horizontalOffset = roffset.exec( pos[ 0 ] );
      verticalOffset = roffset.exec( pos[ 1 ] );
      offsets[ this ] = [
         horizontalOffset ? horizontalOffset[ 0 ] : 0,
         verticalOffset ? verticalOffset[ 0 ] : 0
      ];

      // Reduce to just the positions without the offsets
      options[ this ] = [
         rposition.exec( pos[ 0 ] )[ 0 ],
         rposition.exec( pos[ 1 ] )[ 0 ]
      ];
   } );

   // Normalize collision option
   if ( collision.length === 1 ) {
      collision[ 1 ] = collision[ 0 ];
   }

   if ( options.at[ 0 ] === "right" ) {
      basePosition.left += targetWidth;
   } else if ( options.at[ 0 ] === "center" ) {
      basePosition.left += targetWidth / 2;
   }

   if ( options.at[ 1 ] === "bottom" ) {
      basePosition.top += targetHeight;
   } else if ( options.at[ 1 ] === "center" ) {
      basePosition.top += targetHeight / 2;
   }

   atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
   basePosition.left += atOffset[ 0 ];
   basePosition.top += atOffset[ 1 ];

   return this.each( function() {
      var collisionPosition, using,
         elem = $( this ),
         elemWidth = elem.outerWidth(),
         elemHeight = elem.outerHeight(),
         marginLeft = parseCss( this, "marginLeft" ),
         marginTop = parseCss( this, "marginTop" ),
         collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
            scrollInfo.width,
         collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
            scrollInfo.height,
         position = $.extend( {}, basePosition ),
         myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

      if ( options.my[ 0 ] === "right" ) {
         position.left -= elemWidth;
      } else if ( options.my[ 0 ] === "center" ) {
         position.left -= elemWidth / 2;
      }

      if ( options.my[ 1 ] === "bottom" ) {
         position.top -= elemHeight;
      } else if ( options.my[ 1 ] === "center" ) {
         position.top -= elemHeight / 2;
      }

      position.left += myOffset[ 0 ];
      position.top += myOffset[ 1 ];

      collisionPosition = {
         marginLeft: marginLeft,
         marginTop: marginTop
      };

      $.each( [ "left", "top" ], function( i, dir ) {
         if ( $.ui.position[ collision[ i ] ] ) {
            $.ui.position[ collision[ i ] ][ dir ]( position, {
               targetWidth: targetWidth,
               targetHeight: targetHeight,
               elemWidth: elemWidth,
               elemHeight: elemHeight,
               collisionPosition: collisionPosition,
               collisionWidth: collisionWidth,
               collisionHeight: collisionHeight,
               offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
               my: options.my,
               at: options.at,
               within: within,
               elem: elem
            } );
         }
      } );

      if ( options.using ) {

         // Adds feedback as second argument to using callback, if present
         using = function( props ) {
            var left = targetOffset.left - position.left,
               right = left + targetWidth - elemWidth,
               top = targetOffset.top - position.top,
               bottom = top + targetHeight - elemHeight,
               feedback = {
                  target: {
                     element: target,
                     left: targetOffset.left,
                     top: targetOffset.top,
                     width: targetWidth,
                     height: targetHeight
                  },
                  element: {
                     element: elem,
                     left: position.left,
                     top: position.top,
                     width: elemWidth,
                     height: elemHeight
                  },
                  horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                  vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
               };
            if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
               feedback.horizontal = "center";
            }
            if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
               feedback.vertical = "middle";
            }
            if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
               feedback.important = "horizontal";
            } else {
               feedback.important = "vertical";
            }
            options.using.call( this, props, feedback );
         };
      }

      elem.offset( $.extend( position, { using: using } ) );
   } );
};

$.ui.position = {
   fit: {
      left: function( position, data ) {
         var within = data.within,
            withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
            outerWidth = within.width,
            collisionPosLeft = position.left - data.collisionPosition.marginLeft,
            overLeft = withinOffset - collisionPosLeft,
            overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
            newOverRight;

         // Element is wider than within
         if ( data.collisionWidth > outerWidth ) {

            // Element is initially over the left side of within
            if ( overLeft > 0 && overRight <= 0 ) {
               newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
                  withinOffset;
               position.left += overLeft - newOverRight;

            // Element is initially over right side of within
            } else if ( overRight > 0 && overLeft <= 0 ) {
               position.left = withinOffset;

            // Element is initially over both left and right sides of within
            } else {
               if ( overLeft > overRight ) {
                  position.left = withinOffset + outerWidth - data.collisionWidth;
               } else {
                  position.left = withinOffset;
               }
            }

         // Too far left -> align with left edge
         } else if ( overLeft > 0 ) {
            position.left += overLeft;

         // Too far right -> align with right edge
         } else if ( overRight > 0 ) {
            position.left -= overRight;

         // Adjust based on position and margin
         } else {
            position.left = max( position.left - collisionPosLeft, position.left );
         }
      },
      top: function( position, data ) {
         var within = data.within,
            withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
            outerHeight = data.within.height,
            collisionPosTop = position.top - data.collisionPosition.marginTop,
            overTop = withinOffset - collisionPosTop,
            overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
            newOverBottom;

         // Element is taller than within
         if ( data.collisionHeight > outerHeight ) {

            // Element is initially over the top of within
            if ( overTop > 0 && overBottom <= 0 ) {
               newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
                  withinOffset;
               position.top += overTop - newOverBottom;

            // Element is initially over bottom of within
            } else if ( overBottom > 0 && overTop <= 0 ) {
               position.top = withinOffset;

            // Element is initially over both top and bottom of within
            } else {
               if ( overTop > overBottom ) {
                  position.top = withinOffset + outerHeight - data.collisionHeight;
               } else {
                  position.top = withinOffset;
               }
            }

         // Too far up -> align with top
         } else if ( overTop > 0 ) {
            position.top += overTop;

         // Too far down -> align with bottom edge
         } else if ( overBottom > 0 ) {
            position.top -= overBottom;

         // Adjust based on position and margin
         } else {
            position.top = max( position.top - collisionPosTop, position.top );
         }
      }
   },
   flip: {
      left: function( position, data ) {
         var within = data.within,
            withinOffset = within.offset.left + within.scrollLeft,
            outerWidth = within.width,
            offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
            collisionPosLeft = position.left - data.collisionPosition.marginLeft,
            overLeft = collisionPosLeft - offsetLeft,
            overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
            myOffset = data.my[ 0 ] === "left" ?
               -data.elemWidth :
               data.my[ 0 ] === "right" ?
                  data.elemWidth :
                  0,
            atOffset = data.at[ 0 ] === "left" ?
               data.targetWidth :
               data.at[ 0 ] === "right" ?
                  -data.targetWidth :
                  0,
            offset = -2 * data.offset[ 0 ],
            newOverRight,
            newOverLeft;

         if ( overLeft < 0 ) {
            newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
               outerWidth - withinOffset;
            if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
               position.left += myOffset + atOffset + offset;
            }
         } else if ( overRight > 0 ) {
            newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
               atOffset + offset - offsetLeft;
            if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
               position.left += myOffset + atOffset + offset;
            }
         }
      },
      top: function( position, data ) {
         var within = data.within,
            withinOffset = within.offset.top + within.scrollTop,
            outerHeight = within.height,
            offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
            collisionPosTop = position.top - data.collisionPosition.marginTop,
            overTop = collisionPosTop - offsetTop,
            overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
            top = data.my[ 1 ] === "top",
            myOffset = top ?
               -data.elemHeight :
               data.my[ 1 ] === "bottom" ?
                  data.elemHeight :
                  0,
            atOffset = data.at[ 1 ] === "top" ?
               data.targetHeight :
               data.at[ 1 ] === "bottom" ?
                  -data.targetHeight :
                  0,
            offset = -2 * data.offset[ 1 ],
            newOverTop,
            newOverBottom;
         if ( overTop < 0 ) {
            newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
               outerHeight - withinOffset;
            if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
               position.top += myOffset + atOffset + offset;
            }
         } else if ( overBottom > 0 ) {
            newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
               offset - offsetTop;
            if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
               position.top += myOffset + atOffset + offset;
            }
         }
      }
   },
   flipfit: {
      left: function() {
         $.ui.position.flip.left.apply( this, arguments );
         $.ui.position.fit.left.apply( this, arguments );
      },
      top: function() {
         $.ui.position.flip.top.apply( this, arguments );
         $.ui.position.fit.top.apply( this, arguments );
      }
   }
};

} )();

var position = $.ui.position;


/*!
 * jQuery UI :data 1.14.1
 * https://jqueryui.com
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license.
 * https://jquery.org/license
 */

//>>label: :data Selector
//>>group: Core
//>>description: Selects elements which have data stored under the specified key.
//>>docs: https://api.jqueryui.com/data-selector/


var data = $.extend( $.expr.pseudos, {
   data: $.expr.createPseudo( function( dataName ) {
      return function( elem ) {
         return !!$.data( elem, dataName );
      };
   } )
} );

/*!
 * jQuery UI Disable Selection 1.14.1
 * https://jqueryui.com
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license.
 * https://jquery.org/license
 */

//>>label: disableSelection
//>>group: Core
//>>description: Disable selection of text content within the set of matched elements.
//>>docs: https://api.jqueryui.com/disableSelection/

// This file is deprecated

var disableSelection = $.fn.extend( {
   disableSelection: ( function() {
      var eventType = "onselectstart" in document.createElement( "div" ) ?
         "selectstart" :
         "mousedown";

      return function() {
         return this.on( eventType + ".ui-disableSelection", function( event ) {
            event.preventDefault();
         } );
      };
   } )(),

   enableSelection: function() {
      return this.off( ".ui-disableSelection" );
   }
} );



// Create a local jQuery because jQuery Color relies on it and the
// global may not exist with AMD and a custom build (#10199).
// This module is a noop if used as a regular AMD module.
// eslint-disable-next-line no-unused-vars
var jQuery = $;


/*!
 * jQuery Color Animations v3.0.0
 * https://github.com/jquery/jquery-color
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license.
 * https://jquery.org/license
 *
 * Date: Wed May 15 16:49:44 2024 +0200
 */


   var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " +
      "borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

   class2type = {},
   toString = class2type.toString,

   // plusequals test for += 100 -= 100
   rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,

   // a set of RE's that can match strings and generate color tuples.
   stringParsers = [ {
         re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
         parse: function( execResult ) {
            return [
               execResult[ 1 ],
               execResult[ 2 ],
               execResult[ 3 ],
               execResult[ 4 ]
            ];
         }
      }, {
         re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
         parse: function( execResult ) {
            return [
               execResult[ 1 ] * 2.55,
               execResult[ 2 ] * 2.55,
               execResult[ 3 ] * 2.55,
               execResult[ 4 ]
            ];
         }
      }, {

         // this regex ignores A-F because it's compared against an already lowercased string
         re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?/,
         parse: function( execResult ) {
            return [
               parseInt( execResult[ 1 ], 16 ),
               parseInt( execResult[ 2 ], 16 ),
               parseInt( execResult[ 3 ], 16 ),
               execResult[ 4 ] ?
                  ( parseInt( execResult[ 4 ], 16 ) / 255 ).toFixed( 2 ) :
                  1
            ];
         }
      }, {

         // this regex ignores A-F because it's compared against an already lowercased string
         re: /#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?/,
         parse: function( execResult ) {
            return [
               parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
               parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
               parseInt( execResult[ 3 ] + execResult[ 3 ], 16 ),
               execResult[ 4 ] ?
                  ( parseInt( execResult[ 4 ] + execResult[ 4 ], 16 ) / 255 )
                     .toFixed( 2 ) :
                  1
            ];
         }
      }, {
         re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
         space: "hsla",
         parse: function( execResult ) {
            return [
               execResult[ 1 ],
               execResult[ 2 ] / 100,
               execResult[ 3 ] / 100,
               execResult[ 4 ]
            ];
         }
      } ],

   // jQuery.Color( )
   color = jQuery.Color = function( color, green, blue, alpha ) {
      return new jQuery.Color.fn.parse( color, green, blue, alpha );
   },
   spaces = {
      rgba: {
         props: {
            red: {
               idx: 0,
               type: "byte"
            },
            green: {
               idx: 1,
               type: "byte"
            },
            blue: {
               idx: 2,
               type: "byte"
            }
         }
      },

      hsla: {
         props: {
            hue: {
               idx: 0,
               type: "degrees"
            },
            saturation: {
               idx: 1,
               type: "percent"
            },
            lightness: {
               idx: 2,
               type: "percent"
            }
         }
      }
   },
   propTypes = {
      "byte": {
         floor: true,
         max: 255
      },
      "percent": {
         max: 1
      },
      "degrees": {
         mod: 360,
         floor: true
      }
   },

   // colors = jQuery.Color.names
   colors,

   // local aliases of functions called often
   each = jQuery.each;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
   space.cache = "_" + spaceName;
   space.props.alpha = {
      idx: 3,
      type: "percent",
      def: 1
   };
} );

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
   function( _i, name ) {
      class2type[ "[object " + name + "]" ] = name.toLowerCase();
   } );

function getType( obj ) {
   if ( obj == null ) {
      return obj + "";
   }

   return typeof obj === "object" ?
      class2type[ toString.call( obj ) ] || "object" :
      typeof obj;
}

function clamp( value, prop, allowEmpty ) {
   var type = propTypes[ prop.type ] || {};

   if ( value == null ) {
      return ( allowEmpty || !prop.def ) ? null : prop.def;
   }

   // ~~ is an short way of doing floor for positive numbers
   value = type.floor ? ~~value : parseFloat( value );

   if ( type.mod ) {

      // we add mod before modding to make sure that negatives values
      // get converted properly: -10 -> 350
      return ( value + type.mod ) % type.mod;
   }

   // for now all property types without mod have min and max
   return Math.min( type.max, Math.max( 0, value ) );
}

function stringParse( string ) {
   var inst = color(),
      rgba = inst._rgba = [];

   string = string.toLowerCase();

   each( stringParsers, function( _i, parser ) {
      var parsed,
         match = parser.re.exec( string ),
         values = match && parser.parse( match ),
         spaceName = parser.space || "rgba";

      if ( values ) {
         parsed = inst[ spaceName ]( values );

         // if this was an rgba parse the assignment might happen twice
         // oh well....
         inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
         rgba = inst._rgba = parsed._rgba;

         // exit each( stringParsers ) here because we matched
         return false;
      }
   } );

   // Found a stringParser that handled it
   if ( rgba.length ) {

      // if this came from a parsed string, force "transparent" when alpha is 0
      // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
      if ( rgba.join() === "0,0,0,0" ) {
         jQuery.extend( rgba, colors.transparent );
      }
      return inst;
   }

   // named colors
   return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
   parse: function( red, green, blue, alpha ) {
      if ( red === undefined ) {
         this._rgba = [ null, null, null, null ];
         return this;
      }
      if ( red.jquery || red.nodeType ) {
         red = jQuery( red ).css( green );
         green = undefined;
      }

      var inst = this,
         type = getType( red ),
         rgba = this._rgba = [];

      // more than 1 argument specified - assume ( red, green, blue, alpha )
      if ( green !== undefined ) {
         red = [ red, green, blue, alpha ];
         type = "array";
      }

      if ( type === "string" ) {
         return this.parse( stringParse( red ) || colors._default );
      }

      if ( type === "array" ) {
         each( spaces.rgba.props, function( _key, prop ) {
            rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
         } );
         return this;
      }

      if ( type === "object" ) {
         if ( red instanceof color ) {
            each( spaces, function( _spaceName, space ) {
               if ( red[ space.cache ] ) {
                  inst[ space.cache ] = red[ space.cache ].slice();
               }
            } );
         } else {
            each( spaces, function( _spaceName, space ) {
               var cache = space.cache;
               each( space.props, function( key, prop ) {

                  // if the cache doesn't exist, and we know how to convert
                  if ( !inst[ cache ] && space.to ) {

                     // if the value was null, we don't need to copy it
                     // if the key was alpha, we don't need to copy it either
                     if ( key === "alpha" || red[ key ] == null ) {
                        return;
                     }
                     inst[ cache ] = space.to( inst._rgba );
                  }

                  // this is the only case where we allow nulls for ALL properties.
                  // call clamp with alwaysAllowEmpty
                  inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
               } );

               // everything defined but alpha?
               if ( inst[ cache ] && jQuery.inArray(
                  null,
                  inst[ cache ].slice( 0, 3 )
               ) < 0 ) {

                  // use the default of 1
                  if ( inst[ cache ][ 3 ] == null ) {
                     inst[ cache ][ 3 ] = 1;
                  }

                  if ( space.from ) {
                     inst._rgba = space.from( inst[ cache ] );
                  }
               }
            } );
         }
         return this;
      }
   },
   is: function( compare ) {
      var is = color( compare ),
         same = true,
         inst = this;

      each( spaces, function( _, space ) {
         var localCache,
            isCache = is[ space.cache ];
         if ( isCache ) {
            localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
            each( space.props, function( _, prop ) {
               if ( isCache[ prop.idx ] != null ) {
                  same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
                  return same;
               }
            } );
         }
         return same;
      } );
      return same;
   },
   _space: function() {
      var used = [],
         inst = this;
      each( spaces, function( spaceName, space ) {
         if ( inst[ space.cache ] ) {
            used.push( spaceName );
         }
      } );
      return used.pop();
   },
   transition: function( other, distance ) {
      var end = color( other ),
         spaceName = end._space(),
         space = spaces[ spaceName ],
         startColor = this.alpha() === 0 ? color( "transparent" ) : this,
         start = startColor[ space.cache ] || space.to( startColor._rgba ),
         result = start.slice();

      end = end[ space.cache ];
      each( space.props, function( _key, prop ) {
         var index = prop.idx,
            startValue = start[ index ],
            endValue = end[ index ],
            type = propTypes[ prop.type ] || {};

         // if null, don't override start value
         if ( endValue === null ) {
            return;
         }

         // if null - use end
         if ( startValue === null ) {
            result[ index ] = endValue;
         } else {
            if ( type.mod ) {
               if ( endValue - startValue > type.mod / 2 ) {
                  startValue += type.mod;
               } else if ( startValue - endValue > type.mod / 2 ) {
                  startValue -= type.mod;
               }
            }
            result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
         }
      } );
      return this[ spaceName ]( result );
   },
   blend: function( opaque ) {

      // if we are already opaque - return ourself
      if ( this._rgba[ 3 ] === 1 ) {
         return this;
      }

      var rgb = this._rgba.slice(),
         a = rgb.pop(),
         blend = color( opaque )._rgba;

      return color( jQuery.map( rgb, function( v, i ) {
         return ( 1 - a ) * blend[ i ] + a * v;
      } ) );
   },
   toRgbaString: function() {
      var prefix = "rgba(",
         rgba = jQuery.map( this._rgba, function( v, i ) {
            if ( v != null ) {
               return v;
            }
            return i > 2 ? 1 : 0;
         } );

      if ( rgba[ 3 ] === 1 ) {
         rgba.pop();
         prefix = "rgb(";
      }

      return prefix + rgba.join( ", " ) + ")";
   },
   toHslaString: function() {
      var prefix = "hsla(",
         hsla = jQuery.map( this.hsla(), function( v, i ) {
            if ( v == null ) {
               v = i > 2 ? 1 : 0;
            }

            // catch 1 and 2
            if ( i && i < 3 ) {
               v = Math.round( v * 100 ) + "%";
            }
            return v;
         } );

      if ( hsla[ 3 ] === 1 ) {
         hsla.pop();
         prefix = "hsl(";
      }
      return prefix + hsla.join( ", " ) + ")";
   },
   toHexString: function( includeAlpha ) {
      var rgba = this._rgba.slice(),
         alpha = rgba.pop();

      if ( includeAlpha ) {
         rgba.push( ~~( alpha * 255 ) );
      }

      return "#" + jQuery.map( rgba, function( v ) {

         // default to 0 when nulls exist
         return ( "0" + ( v || 0 ).toString( 16 ) ).substr( -2 );
      } ).join( "" );
   },
   toString: function() {
      return this.toRgbaString();
   }
} );
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
   h = ( h + 1 ) % 1;
   if ( h * 6 < 1 ) {
      return p + ( q - p ) * h * 6;
   }
   if ( h * 2 < 1 ) {
      return q;
   }
   if ( h * 3 < 2 ) {
      return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
   }
   return p;
}

spaces.hsla.to = function( rgba ) {
   if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
      return [ null, null, null, rgba[ 3 ] ];
   }
   var r = rgba[ 0 ] / 255,
      g = rgba[ 1 ] / 255,
      b = rgba[ 2 ] / 255,
      a = rgba[ 3 ],
      max = Math.max( r, g, b ),
      min = Math.min( r, g, b ),
      diff = max - min,
      add = max + min,
      l = add * 0.5,
      h, s;

   if ( min === max ) {
      h = 0;
   } else if ( r === max ) {
      h = ( 60 * ( g - b ) / diff ) + 360;
   } else if ( g === max ) {
      h = ( 60 * ( b - r ) / diff ) + 120;
   } else {
      h = ( 60 * ( r - g ) / diff ) + 240;
   }

   // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
   // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
   if ( diff === 0 ) {
      s = 0;
   } else if ( l <= 0.5 ) {
      s = diff / add;
   } else {
      s = diff / ( 2 - add );
   }
   return [ Math.round( h ) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function( hsla ) {
   if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
      return [ null, null, null, hsla[ 3 ] ];
   }
   var h = hsla[ 0 ] / 360,
      s = hsla[ 1 ],
      l = hsla[ 2 ],
      a = hsla[ 3 ],
      q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
      p = 2 * l - q;

   return [
      Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
      Math.round( hue2rgb( p, q, h ) * 255 ),
      Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
      a
   ];
};


each( spaces, function( spaceName, space ) {
   var props = space.props,
      cache = space.cache,
      to = space.to,
      from = space.from;

   // makes rgba() and hsla()
   color.fn[ spaceName ] = function( value ) {

      // generate a cache for this space if it doesn't exist
      if ( to && !this[ cache ] ) {
         this[ cache ] = to( this._rgba );
      }
      if ( value === undefined ) {
         return this[ cache ].slice();
      }

      var ret,
         type = getType( value ),
         arr = ( type === "array" || type === "object" ) ? value : arguments,
         local = this[ cache ].slice();

      each( props, function( key, prop ) {
         var val = arr[ type === "object" ? key : prop.idx ];
         if ( val == null ) {
            val = local[ prop.idx ];
         }
         local[ prop.idx ] = clamp( val, prop );
      } );

      if ( from ) {
         ret = color( from( local ) );
         ret[ cache ] = local;
         return ret;
      } else {
         return color( local );
      }
   };

   // makes red() green() blue() alpha() hue() saturation() lightness()
   each( props, function( key, prop ) {

      // alpha is included in more than one space
      if ( color.fn[ key ] ) {
         return;
      }
      color.fn[ key ] = function( value ) {
         var local, cur, match, fn,
            vtype = getType( value );

         if ( key === "alpha" ) {
            fn = this._hsla ? "hsla" : "rgba";
         } else {
            fn = spaceName;
         }
         local = this[ fn ]();
         cur = local[ prop.idx ];

         if ( vtype === "undefined" ) {
            return cur;
         }

         if ( vtype === "function" ) {
            value = value.call( this, cur );
            vtype = getType( value );
         }
         if ( value == null && prop.empty ) {
            return this;
         }
         if ( vtype === "string" ) {
            match = rplusequals.exec( value );
            if ( match ) {
               value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
            }
         }
         local[ prop.idx ] = value;
         return this[ fn ]( local );
      };
   } );
} );

// add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
   var hooks = hook.split( " " );
   each( hooks, function( _i, hook ) {
      jQuery.cssHooks[ hook ] = {
         set: function( elem, value ) {
            var parsed;

            if ( value !== "transparent" &&
               ( getType( value ) !== "string" ||
                  ( parsed = stringParse( value ) ) ) ) {
               value = color( parsed || value );
               value = value.toRgbaString();
            }
            elem.style[ hook ] = value;
         }
      };
      jQuery.fx.step[ hook ] = function( fx ) {
         if ( !fx.colorInit ) {
            fx.start = color( fx.elem, hook );
            fx.end = color( fx.end );
            fx.colorInit = true;
         }
         jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
      };
   } );

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
   expand: function( value ) {
      var expanded = {};

      each( [ "Top", "Right", "Bottom", "Left" ], function( _i, part ) {
         expanded[ "border" + part + "Color" ] = value;
      } );
      return expanded;
   }
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {

   // 4.1. Basic color keywords
   aqua: "#00ffff",
   black: "#000000",
   blue: "#0000ff",
   fuchsia: "#ff00ff",
   gray: "#808080",
   green: "#008000",
   lime: "#00ff00",
   maroon: "#800000",
   navy: "#000080",
   olive: "#808000",
   purple: "#800080",
   red: "#ff0000",
   silver: "#c0c0c0",
   teal: "#008080",
   white: "#ffffff",
   yellow: "#ffff00",

   // 4.2.3. "transparent" color keyword
   transparent: [ null, null, null, 0 ],

   _default: "#ffffff"
};


/*!
 * jQuery UI Effects 1.14.1
 * https://jqueryui.com
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license.
 * https://jquery.org/license
 */

//>>label: Effects Core
//>>group: Effects
/* eslint-disable max-len */
//>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.
/* eslint-enable max-len */
//>>docs: https://api.jqueryui.com/category/effects-core/
//>>demos: https://jqueryui.com/effect/


var dataSpace = "ui-effects-",
   dataSpaceStyle = "ui-effects-style",
   dataSpaceAnimated = "ui-effects-animated";

$.effects = {
   effect: {}
};

/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
( function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
   shorthandStyles = {
      border: 1,
      borderBottom: 1,
      borderColor: 1,
      borderLeft: 1,
      borderRight: 1,
      borderTop: 1,
      borderWidth: 1,
      margin: 1,
      padding: 1
   };

$.each(
   [ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ],
   function( _, prop ) {
      $.fx.step[ prop ] = function( fx ) {
         if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
            jQuery.style( fx.elem, prop, fx.end );
            fx.setAttr = true;
         }
      };
   }
);

function camelCase( string ) {
   return string.replace( /-([\da-z])/gi, function( all, letter ) {
      return letter.toUpperCase();
   } );
}

function getElementStyles( elem ) {
   var key, len,
      style = elem.ownerDocument.defaultView.getComputedStyle( elem ),
      styles = {};

   len = style.length;
   while ( len-- ) {
      key = style[ len ];
      if ( typeof style[ key ] === "string" ) {
         styles[ camelCase( key ) ] = style[ key ];
      }
   }

   return styles;
}

function styleDifference( oldStyle, newStyle ) {
   var diff = {},
      name, value;

   for ( name in newStyle ) {
      value = newStyle[ name ];
      if ( oldStyle[ name ] !== value ) {
         if ( !shorthandStyles[ name ] ) {
            if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
               diff[ name ] = value;
            }
         }
      }
   }

   return diff;
}

$.effects.animateClass = function( value, duration, easing, callback ) {
   var o = $.speed( duration, easing, callback );

   return this.queue( function() {
      var animated = $( this ),
         baseClass = animated.attr( "class" ) || "",
         applyClassChange,
         allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

      // Map the animated objects to store the original styles.
      allAnimations = allAnimations.map( function() {
         var el = $( this );
         return {
            el: el,
            start: getElementStyles( this )
         };
      } );

      // Apply class change
      applyClassChange = function() {
         $.each( classAnimationActions, function( i, action ) {
            if ( value[ action ] ) {
               animated[ action + "Class" ]( value[ action ] );
            }
         } );
      };
      applyClassChange();

      // Map all animated objects again - calculate new styles and diff
      allAnimations = allAnimations.map( function() {
         this.end = getElementStyles( this.el[ 0 ] );
         this.diff = styleDifference( this.start, this.end );
         return this;
      } );

      // Apply original class
      animated.attr( "class", baseClass );

      // Map all animated objects again - this time collecting a promise
      allAnimations = allAnimations.map( function() {
         var styleInfo = this,
            dfd = $.Deferred(),
            opts = $.extend( {}, o, {
               queue: false,
               complete: function() {
                  dfd.resolve( styleInfo );
               }
            } );

         this.el.animate( this.diff, opts );
         return dfd.promise();
      } );

      // Once all animations have completed:
      $.when.apply( $, allAnimations.get() ).done( function() {

         // Set the final class
         applyClassChange();

         // For each animated element,
         // clear all css properties that were animated
         $.each( arguments, function() {
            var el = this.el;
            $.each( this.diff, function( key ) {
               el.css( key, "" );
            } );
         } );

         // This is guarnteed to be there if you use jQuery.speed()
         // it also handles dequeuing the next anim...
         o.complete.call( animated[ 0 ] );
      } );
   } );
};

$.fn.extend( {
   addClass: ( function( orig ) {
      return function( classNames, speed, easing, callback ) {
         return speed ?
            $.effects.animateClass.call( this,
               { add: classNames }, speed, easing, callback ) :
            orig.apply( this, arguments );
      };
   } )( $.fn.addClass ),

   removeClass: ( function( orig ) {
      return function( classNames, speed, easing, callback ) {
         return arguments.length > 1 ?
            $.effects.animateClass.call( this,
               { remove: classNames }, speed, easing, callback ) :
            orig.apply( this, arguments );
      };
   } )( $.fn.removeClass ),

   toggleClass: ( function( orig ) {
      return function( classNames, force, speed, easing, callback ) {
         if ( typeof force === "boolean" || force === undefined ) {
            if ( !speed ) {

               // Without speed parameter
               return orig.apply( this, arguments );
            } else {
               return $.effects.animateClass.call( this,
                  ( force ? { add: classNames } : { remove: classNames } ),
                  speed, easing, callback );
            }
         } else {

            // Without force parameter
            return $.effects.animateClass.call( this,
               { toggle: classNames }, force, speed, easing );
         }
      };
   } )( $.fn.toggleClass ),

   switchClass: function( remove, add, speed, easing, callback ) {
      return $.effects.animateClass.call( this, {
         add: add,
         remove: remove
      }, speed, easing, callback );
   }
} );

} )();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

( function() {

if ( $.expr && $.expr.pseudos && $.expr.pseudos.animated ) {
   $.expr.pseudos.animated = ( function( orig ) {
      return function( elem ) {
         return !!$( elem ).data( dataSpaceAnimated ) || orig( elem );
      };
   } )( $.expr.pseudos.animated );
}

if ( $.uiBackCompat === true ) {
   $.extend( $.effects, {

      // Saves a set of properties in a data storage
      save: function( element, set ) {
         var i = 0, length = set.length;
         for ( ; i < length; i++ ) {
            if ( set[ i ] !== null ) {
               element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
            }
         }
      },

      // Restores a set of previously saved properties from a data storage
      restore: function( element, set ) {
         var val, i = 0, length = set.length;
         for ( ; i < length; i++ ) {
            if ( set[ i ] !== null ) {
               val = element.data( dataSpace + set[ i ] );
               element.css( set[ i ], val );
            }
         }
      },

      setMode: function( el, mode ) {
         if ( mode === "toggle" ) {
            mode = el.is( ":hidden" ) ? "show" : "hide";
         }
         return mode;
      },

      // Wraps the element around a wrapper that copies position properties
      createWrapper: function( element ) {

         // If the element is already wrapped, return it
         if ( element.parent().is( ".ui-effects-wrapper" ) ) {
            return element.parent();
         }

         // Wrap the element
         var props = {
               width: element.outerWidth( true ),
               height: element.outerHeight( true ),
               "float": element.css( "float" )
            },
            wrapper = $( "<div></div>" )
               .addClass( "ui-effects-wrapper" )
               .css( {
                  fontSize: "100%",
                  background: "transparent",
                  border: "none",
                  margin: 0,
                  padding: 0
               } ),

            // Store the size in case width/height are defined in % - Fixes #5245
            size = {
               width: element.width(),
               height: element.height()
            },
            active = document.activeElement;

         // Support: Firefox
         // Firefox incorrectly exposes anonymous content
         // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
         try {
            // eslint-disable-next-line no-unused-expressions
            active.id;
         } catch ( e ) {
            active = document.body;
         }

         element.wrap( wrapper );

         // Fixes #7595 - Elements lose focus when wrapped.
         if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
            $( active ).trigger( "focus" );
         }

         // Hotfix for jQuery 1.4 since some change in wrap() seems to actually
         // lose the reference to the wrapped element
         wrapper = element.parent();

         // Transfer positioning properties to the wrapper
         if ( element.css( "position" ) === "static" ) {
            wrapper.css( { position: "relative" } );
            element.css( { position: "relative" } );
         } else {
            $.extend( props, {
               position: element.css( "position" ),
               zIndex: element.css( "z-index" )
            } );
            $.each( [ "top", "left", "bottom", "right" ], function( i, pos ) {
               props[ pos ] = element.css( pos );
               if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
                  props[ pos ] = "auto";
               }
            } );
            element.css( {
               position: "relative",
               top: 0,
               left: 0,
               right: "auto",
               bottom: "auto"
            } );
         }
         element.css( size );

         return wrapper.css( props ).show();
      },

      removeWrapper: function( element ) {
         var active = document.activeElement;

         if ( element.parent().is( ".ui-effects-wrapper" ) ) {
            element.parent().repla